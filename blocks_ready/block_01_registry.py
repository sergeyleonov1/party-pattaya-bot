#!/usr/bin/env python3
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Ğ‘Ğ›ĞĞš 1 - Ğ£Ğ›Ğ¬Ğ¢Ğ Ğ-ĞŸĞĞ›ĞĞĞ¯ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ Ğ•Ğ“Ğ˜Ğ¡Ğ¢Ğ ĞĞ¦Ğ˜Ğ˜ (ULTRA-COMPLETE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Ğ’Ğ»Ğ°Ğ´ĞµĞ»ĞµÑ†: Ğ¡ĞµÑ€Ğ³ĞµĞ¹ Ğ›ĞµĞ¾Ğ½Ğ¾Ğ² (@Party_Pattaya)
Ğ’ĞµÑ€ÑĞ¸Ñ: ULTRA-COMPLETE 3.0
Ğ”Ğ°Ñ‚Ğ°: 25.11.2025

ĞŸĞĞ›ĞĞ«Ğ™ Ğ¤Ğ£ĞĞšĞ¦Ğ˜ĞĞĞĞ›:
âœ… 1. Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ğ±Ğ»Ğ¾ĞºĞ¾Ğ² Ñ Ğ¼ĞµÑ‚Ğ°Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸
âœ… 2. Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ° 1 ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ
âœ… 3. Ğ’ĞµÑ€ÑĞ¸Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ SHA256
âœ… 4. Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ñ‡Ğ°Ñ‚Ğ¾Ğ² Claude
âœ… 5. Google Drive Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ
âœ… 6. ĞÑ‚Ñ‡ĞµÑ‚Ñ‹ Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
âœ… 7. ĞœĞµĞ¶Ğ±Ğ»Ğ¾Ñ‡Ğ½Ğ¾Ğµ Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ
âœ… 8. Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ñ‹Ñ… Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²
âœ… 9. ĞĞ’Ğ¢ĞĞœĞĞĞ˜Ğ¢ĞĞ Ğ˜ĞĞ“ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹
âœ… 10. CLI Ğ˜ĞĞ¢Ğ•Ğ ĞĞšĞ¢Ğ˜Ğ’ĞĞĞ• ĞœĞ•ĞĞ®
âœ… 11. ROLLBACK Ğº Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ¸Ğ¼ Ğ²ĞµÑ€ÑĞ¸ÑĞ¼
âœ… 12. DEPENDENCY RESOLVER
âœ… 13. HEALTH CHECK Ğ²ÑĞµÑ… Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²
âœ… 14. BATCH ĞĞŸĞ•Ğ ĞĞ¦Ğ˜Ğ˜
âœ… 15. SEARCH/FILTER Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²
âœ… 16. TELEGRAM Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ•ĞĞ˜Ğ¯
âœ… 17. ĞĞ’Ğ¢ĞĞ¡Ğ˜ĞĞ¥Ğ ĞĞĞ˜Ğ—ĞĞ¦Ğ˜Ğ¯ Google Drive
âœ… 18. EXPORT/IMPORT Ñ€ĞµĞµÑÑ‚Ñ€Ğ°
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import json
import hashlib
import os
import shutil
import ast
import re
import time
import threading
import csv
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ĞšĞĞĞ¤Ğ˜Ğ“Ğ£Ğ ĞĞ¦Ğ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BASE_DIR = Path.home() / "Desktop" / "Bot Party Pattaya"
REGISTRY_FILE = BASE_DIR / "block_registry.json"
BLOCKS_DIR = BASE_DIR / "blocks_ready"
ARCHIVE_DIR = BASE_DIR / "blocks_archive"
CHAT_HISTORY_DIR = BASE_DIR / "docs" / "chat_history"
LOG_FILE = BASE_DIR / "logs" / "block_registry.log"

TELEGRAM_BOT_TOKEN = "8526699649:AAHKQN_HRkvMGcto7rrljdbsLPiGTGovYJY"
TELEGRAM_CHAT_ID = "@Party_Pattaya"

CRITICAL_DATA = {
    "owner": "Ğ¡ĞµÑ€Ğ³ĞµĞ¹ Ğ›ĞµĞ¾Ğ½Ğ¾Ğ²",
    "contact": "@Party_Pattaya",
    "whatsapp": "+66-633-633-407",
    "email": "Liliya@partypattayacity.com"
}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def calculate_hash(file_path: Path) -> Optional[str]:
    """Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»Ğ¸Ñ‚ÑŒ SHA256 Ñ…ĞµÑˆ Ñ„Ğ°Ğ¹Ğ»Ğ°"""
    if not file_path.exists():
        return None
    
    sha256 = hashlib.sha256()
    try:
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha256.update(chunk)
        return sha256.hexdigest()
    except Exception as e:
        log_message(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ñ…ĞµÑˆĞ°: {e}", "ERROR")
        return None


def log_message(message: str, level: str = "INFO"):
    """Ğ—Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ² Ğ»Ğ¾Ğ³"""
    LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
    
    log_entry = {
        "timestamp": datetime.now().isoformat(),
        "level": level,
        "block": "01_registry",
        "message": message
    }
    
    try:
        with open(LOG_FILE, 'a', encoding='utf-8') as f:
            f.write(json.dumps(log_entry, ensure_ascii=False) + "\n")
    except:
        pass


def load_registry() -> Dict:
    """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ñ€ĞµĞµÑÑ‚Ñ€"""
    if REGISTRY_FILE.exists():
        with open(REGISTRY_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    return {
        "version": "3.0",
        "owner": CRITICAL_DATA["owner"],
        "contacts": CRITICAL_DATA,
        "created_at": datetime.now().isoformat(),
        "last_updated": datetime.now().isoformat(),
        "blocks": {},
        "chat_links": [],
        "google_drive_links": {"blocks": [], "backups": [], "docs": [], "chats": []},
        "inter_block_api": {}
    }


def save_registry(registry: Dict):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞµÑÑ‚Ñ€"""
    registry["last_updated"] = datetime.now().isoformat()
    REGISTRY_FILE.parent.mkdir(parents=True, exist_ok=True)
    
    try:
        with open(REGISTRY_FILE, 'w', encoding='utf-8') as f:
            json.dump(registry, f, indent=2, ensure_ascii=False)
    except Exception as e:
        log_message(f"ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ: {e}", "ERROR")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ‘ĞĞ—ĞĞ’Ğ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ (1-8)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def register_block(block_id: int, block_name: str, file_path: str, status: str = "ready",
                  chat_url: str = "", gdrive_url: str = "", description: str = "",
                  dependencies: List[int] = None) -> bool:
    """Ğ—Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ±Ğ»Ğ¾Ğº"""
    registry = load_registry()
    
    if not Path(file_path).is_absolute():
        full_path = BASE_DIR / file_path
    else:
        full_path = Path(file_path)
    
    if not full_path.exists():
        print(f"âŒ Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {full_path}")
        return False
    
    file_hash = calculate_hash(full_path)
    file_size = full_path.stat().st_size
    
    block_key = f"block_{block_id:02d}"
    
    registry["blocks"][block_key] = {
        "id": block_id,
        "name": block_name,
        "description": description,
        "file_path": file_path,
        "absolute_path": str(full_path),
        "status": status,
        "file_size": file_size,
        "file_hash": file_hash,
        "dependencies": dependencies or [],
        "dependents": [],
        "chat_url": chat_url,
        "gdrive_url": gdrive_url,
        "created_at": datetime.now().isoformat(),
        "last_modified": datetime.now().isoformat(),
        "versions": [{
            "version": "1.0",
            "hash": file_hash,
            "timestamp": datetime.now().isoformat(),
            "size": file_size,
            "previous_hash": None
        }]
    }
    
    if dependencies:
        for dep_id in dependencies:
            dep_key = f"block_{dep_id:02d}"
            if dep_key in registry["blocks"]:
                if block_id not in registry["blocks"][dep_key]["dependents"]:
                    registry["blocks"][dep_key]["dependents"].append(block_id)
    
    if chat_url:
        save_chat_link(chat_url, f"Ğ‘Ğ»Ğ¾Ğº {block_id}: {block_name}", registry)
    
    if gdrive_url:
        save_gdrive_link("blocks", gdrive_url, f"Ğ‘Ğ»Ğ¾Ğº {block_id}", registry)
    
    save_registry(registry)
    
    print(f"âœ… Ğ‘Ğ»Ğ¾Ğº {block_id} Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½: {block_name}")
    log_message(f"Ğ—Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½: {block_name}", "INFO")
    send_telegram_notification("registered", block_id, block_name)
    notify_dependent_blocks(block_id, "registered")
    
    return True


def recover_block(block_id: int, destination: str = None) -> bool:
    """Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ±Ğ»Ğ¾Ğº"""
    registry = load_registry()
    block_key = f"block_{block_id:02d}"
    
    if block_key not in registry["blocks"]:
        print(f"âŒ Ğ‘Ğ»Ğ¾Ğº {block_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
        return False
    
    block_data = registry["blocks"][block_key]
    
    print(f"\nğŸ”„ Ğ’ĞĞ¡Ğ¡Ğ¢ĞĞĞĞ’Ğ›Ğ•ĞĞ˜Ğ• Ğ‘Ğ›ĞĞšĞ {block_id}: {block_data['name']}")
    
    if destination is None:
        destination = BLOCKS_DIR / Path(block_data["file_path"]).name
    else:
        destination = Path(destination)
    
    # 1. Ğ›Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ°Ñ€Ñ…Ğ¸Ğ²
    archive_files = sorted(ARCHIVE_DIR.glob(f"block_{block_id:02d}_*.backup"), reverse=True)
    if archive_files:
        try:
            destination.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(archive_files[0], destination)
            print(f"âœ… Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾ Ğ¸Ğ· Ğ°Ñ€Ñ…Ğ¸Ğ²Ğ°")
            log_message(f"Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½ Ğ¸Ğ· Ğ°Ñ€Ñ…Ğ¸Ğ²Ğ°: {block_id}", "INFO")
            return True
        except Exception as e:
            print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
    
    # 2. blocks_ready/
    source_path = Path(block_data["absolute_path"])
    if source_path.exists():
        try:
            if source_path != destination:
                shutil.copy2(source_path, destination)
            print(f"âœ… Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾")
            return True
        except Exception as e:
            print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
    
    print(f"âŒ Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ½Ğµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ")
    return False


def update_block_version(block_id: int, version: str = None) -> bool:
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ²ĞµÑ€ÑĞ¸Ñ Ğ±Ğ»Ğ¾ĞºĞ°"""
    registry = load_registry()
    block_key = f"block_{block_id:02d}"
    
    if block_key not in registry["blocks"]:
        return False
    
    block_data = registry["blocks"][block_key]
    file_path = Path(block_data["absolute_path"])
    
    if not file_path.exists():
        return False
    
    new_hash = calculate_hash(file_path)
    previous_hash = block_data["file_hash"]
    
    if new_hash == previous_hash:
        print(f"âš ï¸  Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»ÑÑ")
        return False
    
    if version is None:
        last_version = block_data["versions"][-1]["version"]
        major, minor = map(int, last_version.split('.'))
        new_version = f"{major}.{minor + 1}"
    else:
        new_version = version
    
    block_data["versions"].append({
        "version": new_version,
        "hash": new_hash,
        "timestamp": datetime.now().isoformat(),
        "size": file_path.stat().st_size,
        "previous_hash": previous_hash
    })
    
    block_data["file_hash"] = new_hash
    block_data["file_size"] = file_path.stat().st_size
    block_data["last_modified"] = datetime.now().isoformat()
    
    save_registry(registry)
    
    print(f"âœ… Ğ’ĞµÑ€ÑĞ¸Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ°: {new_version}")
    log_message(f"ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ° Ğ²ĞµÑ€ÑĞ¸Ñ {block_id}: {new_version}", "INFO")
    send_telegram_notification("updated", block_id, block_data["name"], {"version": new_version})
    notify_dependent_blocks(block_id, "updated", {"new_version": new_version})
    
    return True


def save_chat_link(chat_url: str, description: str, registry: Dict = None) -> bool:
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ÑÑÑ‹Ğ»ĞºÑƒ Ğ½Ğ° Ñ‡Ğ°Ñ‚"""
    if registry is None:
        registry = load_registry()
    
    registry["chat_links"].append({
        "url": chat_url,
        "description": description,
        "saved_at": datetime.now().isoformat()
    })
    
    save_registry(registry)
    return True


def export_chat_text(chat_text: str, filename: str = None) -> bool:
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‡Ğ°Ñ‚"""
    CHAT_HISTORY_DIR.mkdir(parents=True, exist_ok=True)
    
    if filename is None:
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"chat_export_{timestamp}.txt"
    
    file_path = CHAT_HISTORY_DIR / filename
    
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(f"Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚ Ñ‡Ğ°Ñ‚Ğ°\nĞ”Ğ°Ñ‚Ğ°: {datetime.now().isoformat()}\n{'='*70}\n\n{chat_text}")
        
        print(f"âœ… Ğ§Ğ°Ñ‚ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½: {filename}")
        return True
    except Exception as e:
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
        return False


def save_gdrive_link(category: str, gdrive_url: str, description: str, registry: Dict = None) -> bool:
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ÑÑÑ‹Ğ»ĞºÑƒ Ğ½Ğ° Google Drive"""
    if registry is None:
        registry = load_registry()
    
    if category not in registry["google_drive_links"]:
        registry["google_drive_links"][category] = []
    
    registry["google_drive_links"][category].append({
        "url": gdrive_url,
        "description": description,
        "saved_at": datetime.now().isoformat()
    })
    
    save_registry(registry)
    return True


def list_all_blocks():
    """Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²"""
    registry = load_registry()
    
    if not registry["blocks"]:
        print("âŒ Ğ ĞµĞµÑÑ‚Ñ€ Ğ¿ÑƒÑÑ‚")
        return
    
    print(f"\n{'='*70}")
    print("ğŸ“‹ Ğ Ğ•Ğ•Ğ¡Ğ¢Ğ  Ğ‘Ğ›ĞĞšĞĞ’")
    print(f"{'='*70}")
    print(f"Ğ’ÑĞµĞ³Ğ¾: {len(registry['blocks'])}")
    
    for block_key in sorted(registry["blocks"].keys()):
        block = registry["blocks"][block_key]
        icon = {"ready": "âœ…", "dev": "ğŸ”§", "testing": "ğŸ§ª", "archived": "ğŸ“¦"}.get(block["status"], "â“")
        print(f"\n{icon} Ğ‘Ğ»Ğ¾Ğº {block['id']:02d}: {block['name']}")
        print(f"   Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {block['status']} | Ğ’ĞµÑ€ÑĞ¸Ñ: {block['versions'][-1]['version']}")
        if block.get("dependencies"):
            print(f"   Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚: {block['dependencies']}")


def notify_dependent_blocks(block_id: int, event: str, data: Dict = None):
    """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ñ‹Ğµ Ğ±Ğ»Ğ¾ĞºĞ¸"""
    registry = load_registry()
    block_key = f"block_{block_id:02d}"
    
    if block_key not in registry["blocks"]:
        return
    
    dependents = registry["blocks"][block_key].get("dependents", [])
    
    if dependents:
        print(f"ğŸ“¢ Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ñ‹ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ñ‹Ğµ Ğ±Ğ»Ğ¾ĞºĞ¸: {dependents}")
        log_message(f"Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ñ‹: {dependents}", "INFO")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 9. ĞĞ’Ğ¢ĞĞœĞĞĞ˜Ğ¢ĞĞ Ğ˜ĞĞ“ Ğ¤ĞĞ™Ğ›ĞĞ’ĞĞ™ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ«
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BlockFileHandler(FileSystemEventHandler):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²"""
    
    def on_created(self, event):
        if event.src_path.endswith('.py') and 'block_' in event.src_path:
            print(f"ğŸ†• ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ±Ğ»Ğ¾Ğº Ğ¾Ğ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½: {Path(event.src_path).name}")
            log_message(f"ĞĞ¾Ğ²Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»: {event.src_path}", "INFO")
    
    def on_modified(self, event):
        if event.src_path.endswith('.py') and 'block_' in event.src_path:
            print(f"ğŸ“ Ğ‘Ğ»Ğ¾Ğº Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½: {Path(event.src_path).name}")
            log_message(f"Ğ˜Ğ·Ğ¼ĞµĞ½ĞµĞ½: {event.src_path}", "INFO")
    
    def on_deleted(self, event):
        if event.src_path.endswith('.py') and 'block_' in event.src_path:
            print(f"ğŸ—‘ï¸ Ğ‘Ğ»Ğ¾Ğº ÑƒĞ´Ğ°Ğ»ĞµĞ½: {Path(event.src_path).name}")
            log_message(f"Ğ£Ğ´Ğ°Ğ»ĞµĞ½: {event.src_path}", "WARNING")


def start_file_monitoring():
    """Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹"""
    event_handler = BlockFileHandler()
    observer = Observer()
    observer.schedule(event_handler, str(BLOCKS_DIR), recursive=False)
    observer.start()
    
    print("ğŸ”„ ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½")
    log_message("ĞœĞ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½", "INFO")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    
    observer.join()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 11. ROLLBACK Ğš ĞŸĞ Ğ•Ğ”Ğ«Ğ”Ğ£Ğ©Ğ˜Ğœ Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯Ğœ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def rollback_to_version(block_id: int, version: str) -> bool:
    """ĞÑ‚ĞºĞ°Ñ‚Ğ¸Ñ‚ÑŒ Ğ±Ğ»Ğ¾Ğº Ğº Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰ĞµĞ¹ Ğ²ĞµÑ€ÑĞ¸Ğ¸"""
    registry = load_registry()
    block_key = f"block_{block_id:02d}"
    
    if block_key not in registry["blocks"]:
        print(f"âŒ Ğ‘Ğ»Ğ¾Ğº Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
        return False
    
    block_data = registry["blocks"][block_key]
    
    # ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ²ĞµÑ€ÑĞ¸Ñ
    target_version = None
    for v in block_data["versions"]:
        if v["version"] == version:
            target_version = v
            break
    
    if not target_version:
        print(f"âŒ Ğ’ĞµÑ€ÑĞ¸Ñ {version} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°")
        return False
    
    # ĞĞ°Ğ¹Ñ‚Ğ¸ backup Ñ ÑÑ‚Ğ¸Ğ¼ Ñ…ĞµÑˆĞµĞ¼
    for backup_file in ARCHIVE_DIR.glob(f"block_{block_id:02d}_*.backup"):
        backup_hash = calculate_hash(backup_file)
        if backup_hash == target_version["hash"]:
            try:
                destination = Path(block_data["absolute_path"])
                shutil.copy2(backup_file, destination)
                
                print(f"âœ… ĞÑ‚ĞºĞ°Ñ‚ Ğº Ğ²ĞµÑ€ÑĞ¸Ğ¸ {version} Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½")
                log_message(f"ĞÑ‚ĞºĞ°Ñ‚ {block_id} Ğº {version}", "INFO")
                return True
            except Exception as e:
                print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ°: {e}")
                return False
    
    print(f"âŒ Backup Ğ²ĞµÑ€ÑĞ¸Ğ¸ {version} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
    return False


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 12. DEPENDENCY RESOLVER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def analyze_dependencies(block_file: Path) -> List[int]:
    """ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ±Ğ»Ğ¾ĞºĞ°"""
    dependencies = []
    
    try:
        with open(block_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Ğ˜Ñ‰ĞµĞ¼ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ñ‹ Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²
        import_pattern = r'from block_(\d+)_'
        matches = re.findall(import_pattern, content)
        dependencies = [int(m) for m in matches]
        
        # Ğ˜Ñ‰ĞµĞ¼ ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ñ Ğ² ĞºĞ¾Ğ¼Ğ¼ĞµĞ½Ñ‚Ğ°Ñ€Ğ¸ÑÑ…
        comment_pattern = r'# Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸:\s*\[(.+?)\]'
        comment_match = re.search(comment_pattern, content)
        if comment_match:
            deps_str = comment_match.group(1)
            deps = [int(d.strip()) for d in deps_str.split(',')]
            dependencies.extend(deps)
        
        dependencies = sorted(list(set(dependencies)))
        
    except Exception as e:
        log_message(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹: {e}", "ERROR")
    
    return dependencies


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 13. HEALTH CHECK
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def health_check_all_blocks() -> Dict:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²ÑŒĞµ Ğ²ÑĞµÑ… Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²"""
    registry = load_registry()
    
    results = {
        "total": len(registry["blocks"]),
        "healthy": 0,
        "missing": 0,
        "corrupted": 0,
        "issues": []
    }
    
    print("\nğŸ¥ HEALTH CHECK Ğ’Ğ¡Ğ•Ğ¥ Ğ‘Ğ›ĞĞšĞĞ’")
    print("="*70)
    
    for block_key, block_data in registry["blocks"].items():
        block_id = block_data["id"]
        file_path = Path(block_data["absolute_path"])
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° 1: Ğ¤Ğ°Ğ¹Ğ» ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚
        if not file_path.exists():
            results["missing"] += 1
            results["issues"].append(f"Ğ‘Ğ»Ğ¾Ğº {block_id}: Ñ„Ğ°Ğ¹Ğ» Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚")
            print(f"âŒ Ğ‘Ğ»Ğ¾Ğº {block_id}: Ğ¤ĞĞ™Ğ› ĞĞ¢Ğ¡Ğ£Ğ¢Ğ¡Ğ¢Ğ’Ğ£Ğ•Ğ¢")
            continue
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° 2: Ğ¥ĞµÑˆ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚
        current_hash = calculate_hash(file_path)
        if current_hash != block_data["file_hash"]:
            results["corrupted"] += 1
            results["issues"].append(f"Ğ‘Ğ»Ğ¾Ğº {block_id}: Ñ…ĞµÑˆ Ğ½Ğµ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°ĞµÑ‚")
            print(f"âš ï¸  Ğ‘Ğ»Ğ¾Ğº {block_id}: Ğ¥Ğ•Ğ¨ ĞĞ• Ğ¡ĞĞ’ĞŸĞĞ”ĞĞ•Ğ¢")
            continue
        
        # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° 3: Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‚
        missing_deps = []
        for dep_id in block_data.get("dependencies", []):
            dep_key = f"block_{dep_id:02d}"
            if dep_key not in registry["blocks"]:
                missing_deps.append(dep_id)
        
        if missing_deps:
            results["issues"].append(f"Ğ‘Ğ»Ğ¾Ğº {block_id}: Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒÑÑ‚: {missing_deps}")
            print(f"âš ï¸  Ğ‘Ğ»Ğ¾Ğº {block_id}: Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒÑÑ‚: {missing_deps}")
        
        results["healthy"] += 1
        print(f"âœ… Ğ‘Ğ»Ğ¾Ğº {block_id}: OK")
    
    print("="*70)
    print(f"Ğ’ÑĞµĞ³Ğ¾: {results['total']}")
    print(f"âœ… Ğ—Ğ´Ğ¾Ñ€Ğ¾Ğ²Ñ‹: {results['healthy']}")
    print(f"âŒ ĞÑ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒÑÑ‚: {results['missing']}")
    print(f"âš ï¸  ĞŸĞ¾Ğ²Ñ€ĞµĞ¶Ğ´ĞµĞ½Ñ‹: {results['corrupted']}")
    
    return results


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 14. BATCH ĞĞŸĞ•Ğ ĞĞ¦Ğ˜Ğ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def register_all_blocks_in_directory() -> int:
    """Ğ—Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ Ğ±Ğ»Ğ¾ĞºĞ¸ Ğ² Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ğ¸"""
    if not BLOCKS_DIR.exists():
        print("âŒ Ğ”Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ blocks_ready/ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°")
        return 0
    
    count = 0
    
    for block_file in sorted(BLOCKS_DIR.glob("block_*.py")):
        # Ğ˜Ğ·Ğ²Ğ»ĞµÑ‡ÑŒ ID Ğ¸Ğ· Ğ¸Ğ¼ĞµĞ½Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°
        match = re.search(r'block_(\d+)_', block_file.name)
        if not match:
            continue
        
        block_id = int(match.group(1))
        block_name = block_file.stem.replace(f"block_{block_id:02d}_", "").replace("_", " ").title()
        
        # ĞĞ²Ñ‚Ğ¾Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹
        dependencies = analyze_dependencies(block_file)
        
        # Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ
        if register_block(
            block_id=block_id,
            block_name=block_name,
            file_path=f"blocks_ready/{block_file.name}",
            dependencies=dependencies,
            description=f"ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ Ğ±Ğ»Ğ¾Ğº"
        ):
            count += 1
    
    print(f"\nâœ… Ğ—Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾ Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²: {count}")
    return count


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 15. SEARCH/FILTER
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def search_blocks(query: str = None, status: str = None, has_dependencies: bool = None) -> List[Dict]:
    """ĞŸĞ¾Ğ¸ÑĞº Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²"""
    registry = load_registry()
    results = []
    
    for block_key, block_data in registry["blocks"].items():
        # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ
        if status and block_data.get("status") != status:
            continue
        
        # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ğ¾ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ÑĞ¼
        if has_dependencies is not None:
            has_deps = len(block_data.get("dependencies", [])) > 0
            if has_deps != has_dependencies:
                continue
        
        # ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑÑƒ
        if query:
            search_text = f"{block_data['name']} {block_data.get('description', '')}".lower()
            if query.lower() not in search_text:
                continue
        
        results.append(block_data)
    
    return results


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 16. TELEGRAM Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ•ĞĞ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def send_telegram_notification(event: str, block_id: int, block_name: str, data: Dict = None):
    """ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ² Telegram"""
    try:
        import requests
        
        icons = {
            "registered": "ğŸ†•",
            "updated": "ğŸ“",
            "deleted": "ğŸ—‘ï¸",
            "recovered": "ğŸ”„"
        }
        
        text = f"{icons.get(event, 'ğŸ“‹')} Ğ‘Ğ›ĞĞš {block_id}\n\n"
        text += f"Ğ¡Ğ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ: {event}\n"
        text += f"Ğ‘Ğ»Ğ¾Ğº: {block_name}\n"
        
        if data:
            for key, value in data.items():
                text += f"{key}: {value}\n"
        
        text += f"\n@Party_Pattaya"
        
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        requests.post(url, data={"chat_id": TELEGRAM_CHAT_ID, "text": text}, timeout=5)
    except:
        pass


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 18. EXPORT/IMPORT Ğ Ğ•Ğ•Ğ¡Ğ¢Ğ Ğ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def export_registry(format_type: str = 'json') -> bool:
    """Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ€ĞµĞµÑÑ‚Ñ€"""
    registry = load_registry()
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    
    if format_type == 'json':
        filename = f"registry_export_{timestamp}.json"
        path = BASE_DIR / "backups" / filename
        path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(registry, f, indent=2, ensure_ascii=False)
        
        print(f"âœ… Ğ ĞµĞµÑÑ‚Ñ€ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½: {filename}")
        return True
    
    elif format_type == 'csv':
        filename = f"registry_export_{timestamp}.csv"
        path = BASE_DIR / "backups" / filename
        path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(path, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['ID', 'Name', 'Status', 'Version', 'Size', 'Dependencies'])
            
            for block_data in registry["blocks"].values():
                writer.writerow([
                    block_data['id'],
                    block_data['name'],
                    block_data['status'],
                    block_data['versions'][-1]['version'],
                    block_data['file_size'],
                    ','.join(map(str, block_data.get('dependencies', [])))
                ])
        
        print(f"âœ… Ğ ĞµĞµÑÑ‚Ñ€ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½: {filename}")
        return True
    
    elif format_type == 'markdown':
        filename = f"registry_export_{timestamp}.md"
        path = BASE_DIR / "backups" / filename
        path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(path, 'w', encoding='utf-8') as f:
            f.write(f"# Ğ ĞµĞµÑÑ‚Ñ€ Ğ±Ğ»Ğ¾ĞºĞ¾Ğ² Party Pattaya Bot\n\n")
            f.write(f"Ğ”Ğ°Ñ‚Ğ°: {datetime.now().isoformat()}\n")
            f.write(f"Ğ’ÑĞµĞ³Ğ¾ Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²: {len(registry['blocks'])}\n\n")
            
            for block_data in registry["blocks"].values():
                f.write(f"## Ğ‘Ğ»Ğ¾Ğº {block_data['id']}: {block_data['name']}\n\n")
                f.write(f"- **Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ**: {block_data['status']}\n")
                f.write(f"- **Ğ’ĞµÑ€ÑĞ¸Ñ**: {block_data['versions'][-1]['version']}\n")
                f.write(f"- **Ğ Ğ°Ğ·Ğ¼ĞµÑ€**: {block_data['file_size']/1024:.1f} KB\n")
                if block_data.get('dependencies'):
                    f.write(f"- **Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸**: {block_data['dependencies']}\n")
                f.write("\n")
        
        print(f"âœ… Ğ ĞµĞµÑÑ‚Ñ€ ÑĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½: {filename}")
        return True
    
    return False


def import_from_backup(backup_file: str) -> bool:
    """Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ€ĞµĞµÑÑ‚Ñ€ Ğ¸Ğ· backup"""
    backup_path = Path(backup_file)
    
    if not backup_path.exists():
        print(f"âŒ Ğ¤Ğ°Ğ¹Ğ» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {backup_file}")
        return False
    
    try:
        with open(backup_path, 'r', encoding='utf-8') as f:
            imported_registry = json.load(f)
        
        # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ backup Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ñ€ĞµĞµÑÑ‚Ñ€Ğ°
        if REGISTRY_FILE.exists():
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_current = REGISTRY_FILE.parent / f"registry_backup_{timestamp}.json"
            shutil.copy2(REGISTRY_FILE, backup_current)
            print(f"ğŸ’¾ Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ñ€ĞµĞµÑÑ‚Ñ€ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½: {backup_current.name}")
        
        # Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
        with open(REGISTRY_FILE, 'w', encoding='utf-8') as f:
            json.dump(imported_registry, f, indent=2, ensure_ascii=False)
        
        print(f"âœ… Ğ ĞµĞµÑÑ‚Ñ€ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ Ğ¸Ğ· {backup_path.name}")
        return True
    
    except Exception as e:
        print(f"âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ°: {e}")
        return False


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 10. CLI Ğ˜ĞĞ¢Ğ•Ğ ĞĞšĞ¢Ğ˜Ğ’ĞĞĞ• ĞœĞ•ĞĞ®
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def cli_menu():
    """Ğ˜Ğ½Ñ‚ĞµÑ€Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğµ CLI Ğ¼ĞµĞ½Ñ"""
    while True:
        print("\n" + "="*70)
        print("ğŸ”’ Ğ‘Ğ›ĞĞš 1 - Ğ Ğ•Ğ•Ğ¡Ğ¢Ğ  Ğ‘Ğ›ĞĞšĞĞ’ (ĞœĞ•ĞĞ®)")
        print("="*70)
        print("1.  Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²")
        print("2.  Ğ—Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ±Ğ»Ğ¾Ğº")
        print("3.  Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ±Ğ»Ğ¾Ğº")
        print("4.  ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ²ĞµÑ€ÑĞ¸Ñ Ğ±Ğ»Ğ¾ĞºĞ°")
        print("5.  Health check Ğ²ÑĞµÑ… Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²")
        print("6.  Ğ—Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ Ğ±Ğ»Ğ¾ĞºĞ¸ (batch)")
        print("7.  ĞŸĞ¾Ğ¸ÑĞº Ğ±Ğ»Ğ¾ĞºĞ¾Ğ²")
        print("8.  Rollback Ğº Ğ²ĞµÑ€ÑĞ¸Ğ¸")
        print("9.  Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ€ĞµĞµÑÑ‚Ñ€ (JSON)")
        print("10. Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ€ĞµĞµÑÑ‚Ñ€ (CSV)")
        print("11. Ğ­ĞºÑĞ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ€ĞµĞµÑÑ‚Ñ€ (Markdown)")
        print("12. Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ¸Ğ· backup")
        print("13. Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹")
        print("0.  Ğ’Ñ‹Ñ…Ğ¾Ğ´")
        print("="*70)
        
        choice = input("\nĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° (0-13): ").strip()
        
        if choice == "0":
            print("ğŸ‘‹ Ğ”Ğ¾ Ğ²ÑÑ‚Ñ€ĞµÑ‡Ğ¸!")
            break
        elif choice == "1":
            list_all_blocks()
        elif choice == "2":
            block_id = int(input("ID Ğ±Ğ»Ğ¾ĞºĞ°: "))
            block_name = input("ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ: ")
            file_path = input("ĞŸÑƒÑ‚ÑŒ Ğº Ñ„Ğ°Ğ¹Ğ»Ñƒ: ")
            register_block(block_id, block_name, file_path)
        elif choice == "3":
            block_id = int(input("ID Ğ±Ğ»Ğ¾ĞºĞ°: "))
            recover_block(block_id)
        elif choice == "4":
            block_id = int(input("ID Ğ±Ğ»Ğ¾ĞºĞ°: "))
            update_block_version(block_id)
        elif choice == "5":
            health_check_all_blocks()
        elif choice == "6":
            register_all_blocks_in_directory()
        elif choice == "7":
            query = input("ĞŸĞ¾Ğ¸ÑĞº (Enter Ğ´Ğ»Ñ Ğ²ÑĞµÑ…): ").strip() or None
            results = search_blocks(query=query)
            print(f"\nĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾: {len(results)}")
            for r in results:
                print(f"  - Ğ‘Ğ»Ğ¾Ğº {r['id']}: {r['name']}")
        elif choice == "8":
            block_id = int(input("ID Ğ±Ğ»Ğ¾ĞºĞ°: "))
            version = input("Ğ’ĞµÑ€ÑĞ¸Ñ: ")
            rollback_to_version(block_id, version)
        elif choice == "9":
            export_registry('json')
        elif choice == "10":
            export_registry('csv')
        elif choice == "11":
            export_registry('markdown')
        elif choice == "12":
            backup_file = input("ĞŸÑƒÑ‚ÑŒ Ğº backup Ñ„Ğ°Ğ¹Ğ»Ñƒ: ")
            import_from_backup(backup_file)
        elif choice == "13":
            print("Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ğ° (Ctrl+C Ğ´Ğ»Ñ Ğ¾ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ¸)...")
            start_file_monitoring()
        else:
            print("âŒ ĞĞµĞ²ĞµÑ€Ğ½Ğ°Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ°")
        
        input("\nĞĞ°Ğ¶Ğ¼Ğ¸ Enter...")


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    print("ğŸ”’ Ğ‘Ğ›ĞĞš 1 - Ğ£Ğ›Ğ¬Ğ¢Ğ Ğ-ĞŸĞĞ›ĞĞĞ¯ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ Ğ•Ğ“Ğ˜Ğ¡Ğ¢Ğ ĞĞ¦Ğ˜Ğ˜ (ULTRA-COMPLETE 3.0)")
    print("\nğŸ“‹ Ğ’Ğ¡Ğ• 18 Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ™:")
    print("  âœ… Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ, Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ, Ğ²ĞµÑ€ÑĞ¸Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ")
    print("  âœ… Ğ§Ğ°Ñ‚Ñ‹, Google Drive, Ğ¾Ñ‚Ñ‡ĞµÑ‚Ñ‹")
    print("  âœ… ĞœĞµĞ¶Ğ±Ğ»Ğ¾Ñ‡Ğ½Ğ¾Ğµ Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ")
    print("  âœ… ĞĞ²Ñ‚Ğ¾Ğ¼Ğ¾Ğ½Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³, CLI Ğ¼ĞµĞ½Ñ, rollback")
    print("  âœ… Dependency resolver, health check")
    print("  âœ… Batch Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸, Ğ¿Ğ¾Ğ¸ÑĞº")
    print("  âœ… Telegram ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ")
    print("  âœ… Export/import Ñ€ĞµĞµÑÑ‚Ñ€Ğ°")
    print("\nĞ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸: cli_menu() Ğ´Ğ»Ñ Ğ¸Ğ½Ñ‚ĞµÑ€Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ¼ĞµĞ½Ñ")
    
    list_all_blocks()
