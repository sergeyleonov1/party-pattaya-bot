"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    Ğ’ĞĞ¡Ğ¡Ğ¢ĞĞĞĞ’Ğ›Ğ•ĞĞĞ«Ğ• ĞšĞ Ğ˜Ğ¢Ğ˜Ğ§ĞĞ«Ğ• Ğ‘Ğ›ĞĞšĞ˜
        Ğ‘Ğ›ĞĞš 1, Ğ‘Ğ›ĞĞšĞ˜ 7-10, Ğ‘Ğ›ĞĞš 14, Ğ‘Ğ›ĞĞšĞ˜ 16-17 (ĞŸĞĞ›ĞĞ«Ğ™ Ğ¤Ğ£ĞĞšĞ¦Ğ˜ĞĞĞĞ›)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ğ¢Ğ— Ğ’Ğ•Ğ Ğ¡Ğ˜Ğ¯: v6.0 FINAL (20.11.2025)
Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡: âœ… ĞŸĞĞ›ĞĞ«Ğ™ Ğ ĞĞ‘ĞĞ§Ğ˜Ğ™ ĞšĞĞ”
"""

import json
import logging
import os
from datetime import datetime
from typing import Dict, List, Optional, Any
from collections import Counter
import hashlib

try:
    from langdetect import detect, detect_langs, LangDetectException
except ImportError:
    detect = None
    detect_langs = None
    LangDetectException = Exception


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ‘Ğ›ĞĞš 1: ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜Ğš ĞšĞĞœĞĞĞ” TELEGRAM
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CommandHandler:
    """Ğ‘Ğ›ĞĞš 1: ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ Telegram"""
    
    COMMANDS = {
        'start': 'ĞĞ°Ñ‡Ğ°Ğ»Ğ¾ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹, Ğ²Ñ‹Ğ±Ğ¾Ñ€ ÑĞ·Ñ‹ĞºĞ°, Ğ¿Ñ€Ğ¸Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğµ',
        'menu': 'Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ ÑĞ¾ Ğ²ÑĞµĞ¼Ğ¸ Ğ¾Ğ¿Ñ†Ğ¸ÑĞ¼Ğ¸',
        'help': 'Ğ¡Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ¾ Ğ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑÑ… Ğ±Ğ¾Ñ‚Ğ°',
        'about': 'Ğ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸ Party Pattaya',
        'services': 'Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… ÑƒÑĞ»ÑƒĞ³ Ñ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸ĞµĞ¼',
        'contact': 'ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ğ¡ĞµÑ€Ğ³ĞµÑ',
        'order': 'Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·',
        'myorders': 'ĞœĞ¾Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹',
        'profile': 'ĞœĞ¾Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ',
        'feedback': 'ĞÑ‚Ğ·Ñ‹Ğ² Ğ¸Ğ»Ğ¸ Ğ¶Ğ°Ğ»Ğ¾Ğ±Ğ°',
        'settings': 'ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸',
        'admin': 'ĞĞ´Ğ¼Ğ¸Ğ½ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ'
    }
    
    IMMUTABLE_CONTACTS = {
        'telegram': '@PartyPattayaBot',
        'whatsapp': '+66806370581',
        'email': 'infopartypattayacity@gmail.com'
    }
    
    @staticmethod
    async def handle_start_command(update, context, user_repo):
        """ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ÑÑ‚Ğ²Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ, Ğ²Ñ‹Ğ±Ğ¾Ñ€ ÑĞ·Ñ‹ĞºĞ°, ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ"""
        user = update.effective_user
        user_id = str(user.id)
        
        user_data = {
            'user_id': user_id,
            'username': user.username or 'Unknown',
            'first_name': user.first_name or '',
            'last_name': user.last_name or '',
            'language_code': user.language_code or 'en',
            'created_at': datetime.now().isoformat(),
            'status': 'active',
            'engagement_score': 0.0
        }
        user_repo.save_user(user_id, user_data)
        
        greeting = """
ğŸ‰ Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Party Pattaya Bot!

Ğ¯ Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ñƒ Ğ²Ğ°Ğ¼ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ½ĞµĞ·Ğ°Ğ±Ñ‹Ğ²Ğ°ĞµĞ¼Ğ¾Ğµ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ Ğ² ĞŸĞ°Ñ‚Ñ‚Ğ°Ğ¹Ğµ.

ğŸ“± ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹:
- WhatsApp: +66806370581
- Telegram: @PartyPattayaBot
- Email: infopartypattayacity@gmail.com

Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞ·Ñ‹Ğº / Select Language:
"""
        await update.message.reply_text(greeting)
        return user_id
    
    @staticmethod
    async def handle_menu_command(update, context):
        """ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ"""
        menu_text = """
ğŸ“Œ Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®:

/services - ğŸ“‹ ĞĞ°ÑˆĞ¸ ÑƒÑĞ»ÑƒĞ³Ğ¸
/order - ğŸ‰ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ·
/myorders - ğŸ“¦ ĞœĞ¾Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹
/profile - ğŸ‘¤ ĞœĞ¾Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ
/contact - ğŸ“ ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹
/settings - âš™ï¸ ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
/help - ğŸ†˜ Ğ¡Ğ¿Ñ€Ğ°Ğ²ĞºĞ°
/about - â„¹ï¸ Ğ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸
"""
        await update.message.reply_text(menu_text)
    
    @staticmethod
    async def handle_help_command(update, context):
        """Ğ¡Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ¾ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ°Ñ…"""
        help_text = """
ğŸ†˜ Ğ¡ĞŸĞ ĞĞ’ĞšĞ ĞŸĞ ĞšĞĞœĞĞĞ”ĞĞœ:

/start - ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ Ñ Ğ±Ğ¾Ñ‚Ğ¾Ğ¼
/menu - ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ
/services - Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº ÑƒÑĞ»ÑƒĞ³
/order - Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·
/myorders - Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ²Ğ°ÑˆĞ¸Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
/profile - Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğµ
/contact - ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ ĞºĞ¾Ğ¼Ğ¿Ğ°Ğ½Ğ¸Ğ¸
/feedback - ĞÑÑ‚Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ğ·Ñ‹Ğ²
/settings - Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
/admin - ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€ÑĞºĞ°Ñ Ğ¿Ğ°Ğ½ĞµĞ»ÑŒ
"""
        await update.message.reply_text(help_text)
    
    @staticmethod
    async def handle_services_command(update, context, service_repo):
        """Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… ÑƒÑĞ»ÑƒĞ³"""
        services = service_repo.get_all_services()
        text = "ğŸ“‹ ĞĞĞ¨Ğ˜ Ğ£Ğ¡Ğ›Ğ£Ğ“Ğ˜:\n\n"
        
        for service in services:
            text += f"ğŸŠ {service['name']}\n"
            text += f"   ğŸ’° Ğ¦ĞµĞ½Ğ°: {service['price']}\n"
            text += f"   ğŸ“ {service['description']}\n\n"
        
        await update.message.reply_text(text)
    
    @staticmethod
    async def handle_contact_command(update, context):
        """ĞšĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ñ‹ Ğ¡ĞµÑ€Ğ³ĞµÑ"""
        contact_text = f"""
ğŸ“ ĞšĞĞĞ¢ĞĞšĞ¢Ğ« PARTY PATTAYA:

WhatsApp: {CommandHandler.IMMUTABLE_CONTACTS['whatsapp']}
Telegram: {CommandHandler.IMMUTABLE_CONTACTS['telegram']}
Email: {CommandHandler.IMMUTABLE_CONTACTS['email']}

ĞœÑ‹ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹ 24/7 Ğ´Ğ»Ñ Ğ²Ğ°Ñ! ğŸŒ
"""
        await update.message.reply_text(contact_text)
    
    @staticmethod
    async def handle_order_command(update, context):
        """ĞĞ°Ñ‡Ğ°Ñ‚ÑŒ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
        order_text = """
ğŸ‰ Ğ¡ĞĞ—Ğ”ĞĞĞ˜Ğ• Ğ—ĞĞšĞĞ—Ğ

ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ½Ğ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ:
- Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ
- Ğ’Ñ€ĞµĞ¼Ñ
- ĞšĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ»ÑĞ´ĞµĞ¹
- Ğ¢Ğ¸Ğ¿ ÑƒÑĞ»ÑƒĞ³Ğ¸
- Ğ›ÑĞ±Ñ‹Ğµ Ğ¿Ğ¾Ğ¶ĞµĞ»Ğ°Ğ½Ğ¸Ñ

ĞœÑ‹ ÑĞ²ÑĞ¶ĞµĞ¼ÑÑ Ñ Ğ²Ğ°Ğ¼Ğ¸ Ğ² Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞµĞµ Ğ²Ñ€ĞµĞ¼Ñ! âœ…
"""
        await update.message.reply_text(order_text)
    
    @staticmethod
    async def handle_myorders_command(update, context, order_repo):
        """Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        user_id = str(update.effective_user.id)
        orders = order_repo.get_user_orders(user_id)
        
        if not orders:
            await update.message.reply_text("Ğ£ Ğ²Ğ°Ñ Ğ½ĞµÑ‚ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² ğŸ“¦")
            return
        
        text = "ğŸ“‹ Ğ’ĞĞ¨ Ğ˜Ğ¡Ğ¢ĞĞ Ğ˜Ğ¯ Ğ—ĞĞšĞĞ—ĞĞ’:\n\n"
        for order in orders:
            text += f"Order ID: {order['order_id']}\n"
            text += f"Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {order['status']}\n"
            text += f"Ğ”Ğ°Ñ‚Ğ°: {order['event_date']}\n"
            text += f"Ğ£ÑĞ»ÑƒĞ³Ğ°: {order['service_name']}\n\n"
        
        await update.message.reply_text(text)
    
    @staticmethod
    async def handle_profile_command(update, context, user_repo):
        """ĞœĞ¾Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ"""
        user_id = str(update.effective_user.id)
        user = user_repo.get_user(user_id)
        
        if not user:
            await update.message.reply_text("ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ ğŸ¤”")
            return
        
        profile_text = f"""
ğŸ‘¤ ĞœĞĞ™ ĞŸĞ ĞĞ¤Ğ˜Ğ›Ğ¬:

Ğ˜Ğ¼Ñ: {user.get('first_name', '')} {user.get('last_name', '')}
Username: @{user.get('username', 'unknown')}
Ğ¯Ğ·Ñ‹Ğº: {user.get('language_chosen', 'not set')}
Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {user.get('status', 'unknown')}
Ğ—Ğ°ĞºĞ°Ğ·Ğ¾Ğ²: {user.get('orders_count', 0)}
Ğ’ÑĞµĞ³Ğ¾ Ğ¿Ğ¾Ñ‚Ñ€Ğ°Ñ‡ĞµĞ½Ğ¾: ${user.get('total_spent', 0):.2f}
"""
        await update.message.reply_text(profile_text)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ‘Ğ›ĞĞšĞ˜ 7-10: CRM Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ Ğ˜ Ğ£ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ˜Ğ• ĞŸĞĞ›Ğ¬Ğ—ĞĞ’ĞĞ¢Ğ•Ğ›Ğ¯ĞœĞ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UserRepository:
    """Ğ‘Ğ›ĞĞš 7: CRM ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğ¸"""
    
    def __init__(self, db_path: str = 'users.json'):
        self.db_path = db_path
        self.users: Dict[str, Dict] = {}
        self.load_all_users()
    
    def load_all_users(self):
        """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ²ÑĞµÑ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"""
        if os.path.exists(self.db_path):
            try:
                with open(self.db_path, 'r', encoding='utf-8') as f:
                    self.users = json.load(f)
            except (json.JSONDecodeError, IOError):
                self.users = {}
    
    def save_user(self, user_id: str, user_data: Dict) -> bool:
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        self.users[user_id] = user_data
        return self._persist()
    
    def get_user(self, user_id: str) -> Optional[Dict]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        return self.users.get(user_id)
    
    def update_user(self, user_id: str, field: str, value: Any) -> bool:
        """ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾Ğ»Ğµ Ğ² Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğµ"""
        if user_id not in self.users:
            return False
        self.users[user_id][field] = value
        return self._persist()
    
    def get_user_stats(self) -> Dict:
        """Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°"""
        total = len(self.users)
        active = sum(1 for u in self.users.values() if u.get('status') == 'active')
        return {'total': total, 'active': active}
    
    def search_users(self, query: str) -> List[Dict]:
        """ĞŸĞ¾Ğ¸ÑĞº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"""
        results = []
        query_lower = query.lower()
        for user_id, user in self.users.items():
            if (query_lower in user.get('username', '').lower() or
                query_lower in user.get('first_name', '').lower() or
                query_lower in user.get('email', '').lower()):
                results.append(user)
        return results
    
    def _persist(self) -> bool:
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ² Ñ„Ğ°Ğ¹Ğ»"""
        try:
            with open(self.db_path, 'w', encoding='utf-8') as f:
                json.dump(self.users, f, ensure_ascii=False, indent=2)
            return True
        except IOError:
            return False


class LanguageHistory:
    """Ğ‘Ğ›ĞĞš 8: Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ÑĞ·Ñ‹ĞºĞ¾Ğ² Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
    
    def __init__(self, user_repo: UserRepository):
        self.user_repo = user_repo
    
    def save_language_history(self, user_id: str, old_lang: str, new_lang: str):
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ ÑĞ¼ĞµĞ½Ñƒ ÑĞ·Ñ‹ĞºĞ°"""
        user = self.user_repo.get_user(user_id)
        if not user:
            return False
        
        if 'language_history' not in user:
            user['language_history'] = []
        
        user['language_history'].append({
            'old_language': old_lang,
            'new_language': new_lang,
            'changed_at': datetime.now().isoformat(),
            'reason': 'user_selected'
        })
        
        return self.user_repo.save_user(user_id, user)
    
    def get_language_history(self, user_id: str) -> List[Dict]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ÑĞ¼ĞµĞ½Ñ‹ ÑĞ·Ñ‹ĞºĞ¾Ğ²"""
        user = self.user_repo.get_user(user_id)
        return user.get('language_history', []) if user else []
    
    def get_most_used_language(self, user_id: str) -> Optional[str]:
        """ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ¸Ğ±Ğ¾Ğ»ĞµĞµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼Ñ‹Ğ¹ ÑĞ·Ñ‹Ğº"""
        history = self.get_language_history(user_id)
        if not history:
            user = self.user_repo.get_user(user_id)
            return user.get('language_chosen') if user else None
        
        languages = [entry['new_language'] for entry in history]
        if languages:
            return Counter(languages).most_common(1)[0][0]
        return None
    
    def detect_preferred_language(self, user_id: str) -> str:
        """ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ Ğ¿Ñ€ĞµĞ´Ğ¿Ğ¾Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼Ñ‹Ğ¹ ÑĞ·Ñ‹Ğº"""
        return self.get_most_used_language(user_id) or 'en'


class UserStatistics:
    """Ğ‘Ğ›ĞĞš 9: Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹"""
    
    def __init__(self, user_repo: UserRepository):
        self.user_repo = user_repo
    
    def get_total_users(self) -> int:
        """ĞĞ±Ñ‰ĞµĞµ ĞºĞ¾Ğ»Ğ¸Ñ‡ĞµÑÑ‚Ğ²Ğ¾"""
        return len(self.user_repo.users)
    
    def get_new_users_today(self) -> int:
        """ĞĞ¾Ğ²Ñ‹Ğµ ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ"""
        today = datetime.now().date()
        count = 0
        for user in self.user_repo.users.values():
            created = user.get('created_at', '')
            if created and created[:10] == str(today):
                count += 1
        return count
    
    def get_active_users(self, days: int = 7) -> int:
        """ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Ğ·Ğ° N Ğ´Ğ½ĞµĞ¹"""
        from datetime import timedelta
        start_date = (datetime.now() - timedelta(days=days)).date()
        count = 0
        for user in self.user_repo.users.values():
            last_msg = user.get('last_message', '')
            if last_msg and last_msg[:10] >= str(start_date):
                count += 1
        return count
    
    def get_language_distribution(self) -> Dict[str, int]:
        """Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ ÑĞ·Ñ‹ĞºĞ°Ğ¼"""
        langs = {}
        for user in self.user_repo.users.values():
            lang = user.get('language_chosen', 'unknown')
            langs[lang] = langs.get(lang, 0) + 1
        return langs
    
    def get_status_distribution(self) -> Dict[str, int]:
        """Ğ Ğ°ÑĞ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°Ğ¼"""
        statuses = {}
        for user in self.user_repo.users.values():
            status = user.get('status', 'unknown')
            statuses[status] = statuses.get(status, 0) + 1
        return statuses
    
    def calculate_engagement_score(self, user_id: str) -> float:
        """Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ score Ğ²Ğ¾Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸"""
        user = self.user_repo.get_user(user_id)
        if not user:
            return 0.0
        
        score = 0.0
        if user.get('orders_count', 0) > 0:
            score += min(3, user['orders_count'])
        if user.get('total_spent', 0) > 0:
            score += min(3, user['total_spent'] / 1000)
        if user.get('last_message'):
            score += 2
        if user.get('status') == 'active':
            score += 2
        
        return min(10.0, score)
    
    def get_lifetime_value(self, user_id: str) -> float:
        """Ğ–Ğ¸Ğ·Ğ½ĞµĞ½Ğ½Ğ°Ñ Ñ†ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ"""
        user = self.user_repo.get_user(user_id)
        if not user:
            return 0.0
        return float(user.get('total_spent', 0))


class UserBlockingSystem:
    """Ğ‘Ğ›ĞĞš 10: Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°/Ğ Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°"""
    
    BLOCK_REASONS = [
        'spam', 'offensive_behavior', 'multiple_complaints',
        'admin_request', 'unpaid_orders'
    ]
    
    def __init__(self, user_repo: UserRepository):
        self.user_repo = user_repo
    
    def block_user(self, user_id: str, reason: str) -> bool:
        """Ğ—Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ"""
        if reason not in self.BLOCK_REASONS:
            return False
        
        user = self.user_repo.get_user(user_id)
        if not user:
            return False
        
        user['status'] = 'blocked'
        user['block_reason'] = reason
        user['blocked_at'] = datetime.now().isoformat()
        
        return self.user_repo.save_user(user_id, user)
    
    def unblock_user(self, user_id: str) -> bool:
        """Ğ Ğ°Ğ·Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ"""
        user = self.user_repo.get_user(user_id)
        if not user:
            return False
        
        user['status'] = 'active'
        user['block_reason'] = None
        user['unblocked_at'] = datetime.now().isoformat()
        
        return self.user_repo.save_user(user_id, user)
    
    def get_blocked_users(self) -> List[Dict]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ñ…"""
        return [u for u in self.user_repo.users.values() 
                if u.get('status') == 'blocked']
    
    def is_user_blocked(self, user_id: str) -> bool:
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ Ğ»Ğ¸"""
        user = self.user_repo.get_user(user_id)
        return user.get('status') == 'blocked' if user else False
    
    def get_block_reason(self, user_id: str) -> Optional[str]:
        """ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ° Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸"""
        user = self.user_repo.get_user(user_id)
        return user.get('block_reason') if user else None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ‘Ğ›ĞĞš 14: Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ•ĞĞ˜Ğ¯ Ğ Ğ—ĞĞšĞĞ—ĞĞ¥
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class OrderNotifications:
    """Ğ‘Ğ›ĞĞš 14: Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğ°Ñ…"""
    
    @staticmethod
    async def notify_order_created(order_id: str, order_data: Dict, 
                                   application, user_id: int, admin_id: int):
        """Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ¸Ñ‚ÑŒ Ğ¾ Ğ½Ğ¾Ğ²Ğ¾Ğ¼ Ğ·Ğ°ĞºĞ°Ğ·Ğµ"""
        client_msg = f"""
ğŸ‰ Ğ—ĞĞšĞĞ— ĞŸĞ Ğ˜ĞĞ¯Ğ¢!

Order ID: {order_id}
Ğ£ÑĞ»ÑƒĞ³Ğ°: {order_data.get('service_name', 'N/A')}
Ğ”Ğ°Ñ‚Ğ°: {order_data.get('event_date', 'N/A')}
Ğ’Ñ€ĞµĞ¼Ñ: {order_data.get('event_time', 'N/A')}

Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ğ²Ğ°ÑˆÑƒ Ğ·Ğ°ÑĞ²ĞºÑƒ! ĞœÑ‹ ÑĞ²ÑĞ¶ĞµĞ¼ÑÑ Ñ Ğ²Ğ°Ğ¼Ğ¸ Ğ² Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞµĞµ Ğ²Ñ€ĞµĞ¼Ñ. âœ…
"""
        await application.bot.send_message(chat_id=user_id, text=client_msg)
        
        admin_msg = f"""
ğŸ”” ĞĞĞ’Ğ«Ğ™ Ğ—ĞĞšĞĞ—!

Order ID: {order_id}
ĞšĞ»Ğ¸ĞµĞ½Ñ‚ ID: {user_id}
Ğ£ÑĞ»ÑƒĞ³Ğ°: {order_data.get('service_name', 'N/A')}
Ğ¡ÑƒĞ¼Ğ¼Ğ°: ${order_data.get('price_estimate', 0)}
Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ: {order_data.get('event_date', 'N/A')}

âš¡ Ğ¢Ğ Ğ•Ğ‘Ğ£Ğ•Ğ¢Ğ¡Ğ¯ ĞĞ‘Ğ ĞĞ‘ĞĞ¢ĞšĞ!
"""
        await application.bot.send_message(chat_id=admin_id, text=admin_msg)
    
    @staticmethod
    async def notify_order_confirmed(order_id: str, user_id: int, application):
        """Ğ—Ğ°ĞºĞ°Ğ· Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½"""
        msg = f"""
âœ… Ğ—ĞĞšĞĞ— ĞŸĞĞ”Ğ¢Ğ’Ğ•Ğ Ğ–Ğ”Ğ•Ğ!

Order ID: {order_id}

Ğ’Ğ°Ñˆ Ğ·Ğ°ĞºĞ°Ğ· Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½! ĞœÑ‹ Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ¸Ğ¼ÑÑ Ğº Ğ²Ğ°ÑˆĞµĞ¼Ñƒ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ. ğŸŠ
"""
        await application.bot.send_message(chat_id=user_id, text=msg)
    
    @staticmethod
    async def notify_order_completed(order_id: str, user_id: int, application):
        """Ğ¡Ğ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾"""
        msg = f"""
ğŸ‰ Ğ¡ĞĞ‘Ğ«Ğ¢Ğ˜Ğ• Ğ—ĞĞ’Ğ•Ğ Ğ¨Ğ•ĞĞ!

Order ID: {order_id}

Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° Ğ²Ñ‹Ğ±Ğ¾Ñ€ Party Pattaya! 

ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¾ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¾Ñ‚Ğ·Ñ‹Ğ²:
/feedback
"""
        await application.bot.send_message(chat_id=user_id, text=msg)
    
    @staticmethod
    async def notify_order_cancelled(order_id: str, user_id: int, 
                                     reason: str, application):
        """Ğ—Ğ°ĞºĞ°Ğ· Ğ¾Ñ‚Ğ¼ĞµĞ½ĞµĞ½"""
        msg = f"""
âŒ Ğ—ĞĞšĞĞ— ĞĞ¢ĞœĞ•ĞĞ•Ğ

Order ID: {order_id}
ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ°: {reason}

Ğ•ÑĞ»Ğ¸ Ñƒ Ğ²Ğ°Ñ ĞµÑÑ‚ÑŒ Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹, ÑĞ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ Ğ½Ğ°Ğ¼Ğ¸:
/contact
"""
        await application.bot.send_message(chat_id=user_id, text=msg)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ‘Ğ›ĞĞš 16: AUTO-DETECT Ğ¯Ğ—Ğ«ĞšĞ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class LanguageDetector:
    """Ğ‘Ğ›ĞĞš 16: Auto-detect ÑĞ·Ñ‹ĞºĞ°"""
    
    SUPPORTED_LANGUAGES = {
        'ru': 'Russian', 'en': 'English', 'th': 'Thai', 'es': 'Spanish',
        'fr': 'French', 'de': 'German', 'it': 'Italian', 'pt': 'Portuguese',
        'zh': 'Chinese', 'ja': 'Japanese', 'ko': 'Korean', 'vi': 'Vietnamese',
        'id': 'Indonesian', 'tl': 'Filipino', 'ar': 'Arabic', 'tr': 'Turkish',
        'pl': 'Polish', 'nl': 'Dutch', 'sv': 'Swedish', 'da': 'Danish'
    }
    
    @staticmethod
    def detect_language(text: str) -> str:
        """ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº"""
        if not text or len(text) < 3:
            return 'en'
        
        try:
            if detect:
                lang = detect(text)
                return lang if lang in LanguageDetector.SUPPORTED_LANGUAGES else 'en'
        except (LangDetectException, Exception):
            pass
        
        return 'en'
    
    @staticmethod
    def get_language_code(text: str) -> str:
        """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ´ ÑĞ·Ñ‹ĞºĞ°"""
        return LanguageDetector.detect_language(text)
    
    @staticmethod
    def detect_user_language(user_id: str, user_repo: UserRepository) -> str:
        """ĞĞ¿Ñ€ĞµĞ´ĞµĞ»Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        user = user_repo.get_user(user_id)
        if not user:
            return 'en'
        
        return user.get('language_chosen', 
                       user.get('language_code', 'en'))
    
    @staticmethod
    def update_user_detected_language(user_id: str, language: str, 
                                     user_repo: UserRepository) -> bool:
        """ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        if language not in LanguageDetector.SUPPORTED_LANGUAGES:
            return False
        
        return user_repo.update_user(user_id, 'language_chosen', language)
    
    @staticmethod
    def confidence_score(text: str, language: str) -> float:
        """Ğ£Ğ²ĞµÑ€ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ"""
        try:
            if not detect_langs:
                return 0.5
            
            langs = detect_langs(text)
            for lang in langs:
                if lang.lang == language:
                    return lang.prob
            return 0.1
        except (LangDetectException, Exception):
            return 0.0


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ‘Ğ›ĞĞš 17: SELF-LEARNING Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SelfLearningSystem:
    """Ğ‘Ğ›ĞĞš 17: Self-Learning ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°"""
    
    def __init__(self, db_path: str = 'ai_learning_data.json'):
        self.db_path = db_path
        self.data = {
            'successful_interactions': [],
            'positive_feedback': [],
            'frequent_questions': {},
            'effective_responses': {},
            'user_preferences': {},
            'engagement_metrics': {},
            'improvement_suggestions': []
        }
        self.load()
    
    def load(self):
        """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ"""
        if os.path.exists(self.db_path):
            try:
                with open(self.db_path, 'r', encoding='utf-8') as f:
                    self.data = json.load(f)
            except (json.JSONDecodeError, IOError):
                pass
    
    def save(self) -> bool:
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ"""
        try:
            with open(self.db_path, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2)
            return True
        except IOError:
            return False
    
    def save_interaction(self, user_id: str, message: str, response: str, 
                        success: bool) -> bool:
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ²Ğ·Ğ°Ğ¸Ğ¼Ğ¾Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ"""
        interaction = {
            'user_id': user_id,
            'user_message': message,
            'ai_response': response,
            'success': success,
            'timestamp': datetime.now().isoformat()
        }
        self.data['successful_interactions'].append(interaction)
        return self.save()
    
    def save_positive_feedback(self, interaction_id: int, rating: int, 
                              comment: str = '') -> bool:
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ğ·Ñ‹Ğ²"""
        feedback = {
            'interaction_id': interaction_id,
            'rating': rating,
            'comment': comment,
            'timestamp': datetime.now().isoformat()
        }
        self.data['positive_feedback'].append(feedback)
        return self.save()
    
    def track_faq(self, question: str, answer: str, success_rate: float) -> bool:
        """ĞÑ‚ÑĞ»ĞµĞ¶Ğ¸Ğ²Ğ°Ñ‚ÑŒ FAQ"""
        key = self._hash_question(question)
        self.data['frequent_questions'][key] = {
            'question': question,
            'answer': answer,
            'success_rate': success_rate,
            'count': self.data['frequent_questions'].get(key, {}).get('count', 0) + 1
        }
        return self.save()
    
    def analyze_learning_data(self) -> Dict:
        """ĞĞ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ"""
        total_interactions = len(self.data['successful_interactions'])
        successful = sum(1 for i in self.data['successful_interactions'] 
                        if i.get('success'))
        
        return {
            'total_interactions': total_interactions,
            'successful_interactions': successful,
            'success_rate': successful / total_interactions if total_interactions > 0 else 0,
            'total_faqs': len(self.data['frequent_questions']),
            'total_feedback': len(self.data['positive_feedback']),
            'avg_rating': self._calculate_avg_rating()
        }
    
    def generate_improvement_suggestions(self) -> List[str]:
        """Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¸"""
        suggestions = []
        analysis = self.analyze_learning_data()
        
        if analysis['success_rate'] < 0.7:
            suggestions.append("Ğ£Ğ»ÑƒÑ‡ÑˆĞ¸Ñ‚ÑŒ ĞºĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¾Ğ² AI")
        
        if len(self.data['frequent_questions']) > 10:
            suggestions.append("ĞĞ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ FAQ")
        
        if analysis['avg_rating'] < 3.5:
            suggestions.append("ĞŸĞµÑ€ĞµÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ğ¸Ñ Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ")
        
        return suggestions
    
    def update_ai_weights(self, metrics: Dict) -> bool:
        """ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ²ĞµÑĞ° AI"""
        self.data['engagement_metrics'] = metrics
        return self.save()
    
    @staticmethod
    def _hash_question(question: str) -> str:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ñ…ĞµÑˆ"""
        return hashlib.sha256(question.encode()).hexdigest()[:16]
    
    def _calculate_avg_rating(self) -> float:
        """Ğ¡Ñ€ĞµĞ´Ğ½ÑÑ Ğ¾Ñ†ĞµĞ½ĞºĞ°"""
        if not self.data['positive_feedback']:
            return 0.0
        ratings = [f.get('rating', 0) for f in self.data['positive_feedback']]
        return sum(ratings) / len(ratings) if ratings else 0.0


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• ĞšĞ›ĞĞ¡Ğ¡Ğ«
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class OrderRepository:
    """Ğ ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²"""
    
    def __init__(self, db_path: str = 'orders.json'):
        self.db_path = db_path
        self.orders: Dict[str, Dict] = {}
        self.load_all_orders()
    
    def load_all_orders(self):
        """Ğ—Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹"""
        if os.path.exists(self.db_path):
            try:
                with open(self.db_path, 'r', encoding='utf-8') as f:
                    self.orders = json.load(f)
            except (json.JSONDecodeError, IOError):
                self.orders = {}
    
    def get_user_orders(self, user_id: str) -> List[Dict]:
        """Ğ—Ğ°ĞºĞ°Ğ·Ñ‹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ"""
        return [o for o in self.orders.values() if o.get('user_id') == user_id]
    
    def get_all_orders(self) -> List[Dict]:
        """Ğ’ÑĞµ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹"""
        return list(self.orders.values())
    
    def save_order(self, order_id: str, order_data: Dict) -> bool:
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ"""
        self.orders[order_id] = order_data
        return self._persist()
    
    def _persist(self) -> bool:
        """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ² Ñ„Ğ°Ğ¹Ğ»"""
        try:
            with open(self.db_path, 'w', encoding='utf-8') as f:
                json.dump(self.orders, f, ensure_ascii=False, indent=2)
            return True
        except IOError:
            return False


class ServiceRepository:
    """Ğ ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹ ÑƒÑĞ»ÑƒĞ³"""
    
    def __init__(self):
        self.services = [
            {
                'id': 'yacht',
                'name': 'ğŸš¤ ĞÑ€ĞµĞ½Ğ´Ğ° ÑÑ…Ñ‚Ñ‹',
                'description': 'ĞŸÑ€Ğ¸Ğ²Ğ°Ñ‚Ğ½Ğ°Ñ ÑÑ…Ñ‚Ğ° Ğ´Ğ»Ñ Ğ²ĞµÑ‡ĞµÑ€Ğ¸Ğ½ĞºĞ¸, ÑĞ²Ğ°Ğ´ÑŒĞ±Ñ‹ Ğ¸Ğ»Ğ¸ ĞºĞ¾Ñ€Ğ¿Ğ¾Ñ€Ğ°Ñ‚Ğ¸Ğ²Ğ°',
                'price': '$500-2000'
            },
            {
                'id': 'party',
                'name': 'ğŸ‰ ĞÑ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ²ĞµÑ‡ĞµÑ€Ğ¸Ğ½ĞºĞ¸',
                'description': 'ĞŸĞ¾Ğ»Ğ½Ğ°Ñ Ğ¾Ñ€Ğ³Ğ°Ğ½Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ',
                'price': '$300-1500'
            },
            {
                'id': 'vip',
                'name': 'ğŸ‘‘ VIP ÑƒÑĞ»ÑƒĞ³Ğ¸',
                'description': 'ĞŸÑ€ĞµĞ¼Ğ¸ÑƒĞ¼ Ğ¾Ğ±ÑĞ»ÑƒĞ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ²Ğ°ÑˆĞ¸Ñ… Ğ³Ğ¾ÑÑ‚ĞµĞ¹',
                'price': '$200-1000'
            }
        ]
    
    def get_all_services(self) -> List[Dict]:
        """Ğ’ÑĞµ ÑƒÑĞ»ÑƒĞ³Ğ¸"""
        return self.services


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def initialize_restored_blocks():
    """Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ²ÑĞµ Ğ±Ğ»Ğ¾ĞºĞ¸"""
    user_repo = UserRepository()
    order_repo = OrderRepository()
    service_repo = ServiceRepository()
    
    language_hist = LanguageHistory(user_repo)
    user_stats = UserStatistics(user_repo)
    user_blocking = UserBlockingSystem(user_repo)
    language_detector = LanguageDetector()
    learning_system = SelfLearningSystem()
    
    return {
        'command_handler': CommandHandler,
        'user_repo': user_repo,
        'order_repo': order_repo,
        'service_repo': service_repo,
        'language_history': language_hist,
        'user_stats': user_stats,
        'user_blocking': user_blocking,
        'order_notifications': OrderNotifications,
        'language_detector': language_detector,
        'learning_system': learning_system
    }


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    blocks = initialize_restored_blocks()
    logger.info("âœ… Ğ’Ğ¡Ğ• Ğ’ĞĞ¡Ğ¡Ğ¢ĞĞĞĞ’Ğ›Ğ•ĞĞĞ«Ğ• Ğ‘Ğ›ĞĞšĞ˜ Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—Ğ˜Ğ ĞĞ’ĞĞĞ«")
    logger.info(f"ğŸ“¦ Ğ‘Ğ›ĞĞš 1: CommandHandler")
    logger.info(f"ğŸ‘¥ Ğ‘Ğ›ĞĞšĞ˜ 7-10: CRM ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°")
    logger.info(f"ğŸ“¬ Ğ‘Ğ›ĞĞš 14: OrderNotifications")
    logger.info(f"ğŸŒ Ğ‘Ğ›ĞĞš 16: LanguageDetector")
    logger.info(f"ğŸ¤– Ğ‘Ğ›ĞĞš 17: SelfLearningSystem")
